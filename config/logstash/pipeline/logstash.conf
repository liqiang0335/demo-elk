input {
  beats {
    port => 5044
  }
}

filter {
  # 第一步：提取并清理JSON内容
  grok {
    match => { 
      "message" => "^\[%{TIMESTAMP_ISO8601:log_timestamp}\] /%{IP:client_ip}:%{INT:client_port} - %{GREEDYDATA:json_content}"
    }
    tag_on_failure => ["_grokparsefailure"]
  }
  
  # 第二步：解析JSON
  if [json_content] {
    json {
      source => "json_content"
      target => "parsed_data"
      skip_on_invalid_json => true
    }
  }
  
  # 第三步：如果JSON解析失败，记录错误
  if "_jsonparsefailure" in [tags] {
    mutate {
      add_field => { 
        "json_parse_error" => "true"
        "raw_json" => "%{json_content}"
      }
    }
  }
  
  # 第四步：提取所有重要字段到根级别
  if [parsed_data] {
    # 从header提取字段
    if [parsed_data][header][msgId] {
      mutate {
        add_field => { "msgId" => "%{[parsed_data][header][msgId]}" }
        convert => { "msgId" => "float" }
      }
    }
    
    if [parsed_data][header][msgType] {
      mutate {
        add_field => { "msgType" => "%{[parsed_data][header][msgType]}" }
      }
    }
    
    if [parsed_data][header][subType] {
      mutate {
        add_field => { "subType" => "%{[parsed_data][header][subType]}" }
      }
    }
    
    # 从device提取字段
    if [parsed_data][device][gatewaySn] {
      mutate {
        add_field => { "gatewaySn" => "%{[parsed_data][device][gatewaySn]}" }
      }
    }
    
    # 从payload提取字段
    if [parsed_data][payload][dataType] {
      mutate {
        add_field => { "dataType" => "%{[parsed_data][payload][dataType]}" }
      }
    }
    
    if [parsed_data][payload][sn] {
      mutate {
        add_field => { "sn" => "%{[parsed_data][payload][sn]}" }
      }
    }
    
    if [parsed_data][payload][bat] {
      mutate {
        add_field => { "bat" => "%{[parsed_data][payload][bat]}" }
        convert => { "bat" => "integer" }
      }
    }
    
    # 处理dataList数组
    if [parsed_data][payload][dataList] {
      ruby {
        code => '
          begin
            data_list = event.get("[parsed_data][payload][dataList]")
            if data_list && data_list.is_a?(Array)
              # 将dataList存储为数组
              event.set("dataList", data_list)
              
              # 也可以将dataList的数量存储下来
              event.set("dataList_count", data_list.length)
            end
          rescue => e
            event.set("dataList_error", e.message)
          end
        '
      }
    }
    
    # 复制完整的header、device和payload到根级别（保留原始结构）
    if [parsed_data][header] {
      mutate {
        add_field => { "header" => "%{[parsed_data][header]}" }
      }
    }
    
    if [parsed_data][device] {
      mutate {
        add_field => { "device" => "%{[parsed_data][device]}" }
      }
    }
    
    if [parsed_data][payload] {
      mutate {
        add_field => { "payload" => "%{[parsed_data][payload]}" }
      }
    }
  }
  
  # 第五步：设置@timestamp从msgId（毫秒时间戳）
  if [msgId] {
    ruby {
      code => '
        begin
          msg_id = event.get("msgId")
          if msg_id
            # msgId是以毫秒为单位的时间戳
            timestamp = Time.at(msg_id.to_f / 1000.0)
            event.set("@timestamp", timestamp)
          end
        rescue => e
          event.set("timestamp_error", e.message)
        end
      '
    }
  }
  
  # 第六步：添加额外的元数据
  mutate {
    add_field => { 
      "service" => "iot_gateway"
      "log_source_timestamp" => "%{log_timestamp}"
      "client_address" => "%{client_ip}:%{client_port}"
    }
  }
  
  # 第七步：清理不需要的字段
  mutate {
    remove_field => [ "message", "json_content", "parsed_data", "host", "log", "input", "agent", "ecs", "event", "@version", "log_timestamp", "client_ip", "client_port" ]
  }
}

output {
  # 输出到 Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "iot-logs-%{+YYYY.MM.dd}"
    # 使用msgId作为文档ID确保不重复
    document_id => "%{msgId}"
  }
  
  # 输出到控制台用于调试（生产环境可以注释掉）
  stdout {
    codec => rubydebug
  }
}
