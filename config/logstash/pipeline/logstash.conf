input {
  beats {
    port => 5044
  }
}

filter {
  # 过滤 heartbeat 消息
  if [message] =~ /.*"heartbeat".*/ {
    drop {}
  }

  # 解析日志行的基本结构: [timestamp] /ip:port - json_data
  grok {
    match => { 
      "message" => "^\[%{DATA:log_timestamp}\] /%{IPORHOST:client_ip}:%{INT:client_port} - %{GREEDYDATA:raw_json}" 
    }
    tag_on_failure => ["_grokparsefailure"]
  }
  
  # 解析时间戳
  if "_grokparsefailure" not in [tags] and [log_timestamp] {
    date {
      match => [ "log_timestamp", "yyyy-MM-dd HH:mm:ss" ]
      target => "log_time"
    }
  }
  
  # 清理并修复JSON数据
  if [raw_json] {
    # 第一步：移除续行中的时间戳和IP前缀
    # 这是最重要的一步，因为续行会包含完整的时间戳和IP前缀
    mutate {
      gsub => [
        # 移除所有续行中的时间戳和IP前缀（包括前导的换行符）
        "raw_json", "[\r\n]+\[[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}\] /[^:]+:\d+ - ", ""
      ]
    }
    
    # 第二步：清理多余的空白字符，但保留JSON结构中必要的空格
    mutate {
      gsub => [
        # 移除多余的换行符和制表符
        "raw_json", "[\r\n\t]+", "",
        # 将多个连续空格压缩为一个空格
        "raw_json", "\s{2,}", " ",
        # 移除JSON符号前后不必要的空格
        "raw_json", "\s*([,:\[\]{}])\s*", "\1"
      ]
    }
    
    # 尝试解析JSON
    json {
      source => "raw_json"
      target => "parsed_data"
      skip_on_invalid_json => true
    }
    
    # 如果JSON解析失败，尝试修复
    if "_jsonparsefailure" in [tags] {
      ruby {
        code => '
          begin
            raw_json = event.get("raw_json")
            if raw_json
              # 第一步：移除所有续行的时间戳和IP前缀
              # 使用更通用的模式，处理各种换行符组合
              cleaned_json = raw_json.gsub(/[\r\n]+\[[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}\] \/[^:]+:\d+ - /, "")
              
              # 第二步：移除所有换行符和多余的空白
              cleaned_json = cleaned_json.gsub(/[\r\n\t]+/, "")
              
              # 第三步：处理可能被断开的内容
              # 3.1 修复被断开的数字（如 "317 9" -> "3179"）
              cleaned_json = cleaned_json.gsub(/(\d+)\s+(\d+)/, "\\1\\2")
              
              # 3.2 修复被断开的字符串值（如 "0.00", "0.00" 被断开）
              cleaned_json = cleaned_json.gsub(/"\s*,\s*"/, "\",\"")
              
              # 3.3 修复被断开的数组元素
              cleaned_json = cleaned_json.gsub(/\]\s*,\s*\[/, "],[")
              
              # 3.4 修复JSON符号周围的多余空格
              cleaned_json = cleaned_json.gsub(/\s*([,:\[\]{}])\s*/, "\\1")
              
              # 3.5 在必要的地方保留空格（如对象属性之间）
              cleaned_json = cleaned_json.gsub(/([}\]])([{"])/, "\\1 \\2")
              
              # 记录修复前后的JSON用于调试
              event.set("debug_original_json", raw_json) if raw_json.length < 1000
              event.set("debug_cleaned_json", cleaned_json) if cleaned_json.length < 1000
              
              # 尝试解析修复后的JSON
              parsed = JSON.parse(cleaned_json)
              event.set("parsed_data", parsed)
              event.remove("_jsonparsefailure")
              event.tag("_json_fixed")
            end
          rescue => e
            event.tag("_jsonparsefailure_final")
            event.set("json_error", e.message)
            # 保留前100个字符用于调试
            event.set("json_error_preview", cleaned_json[0..100] + "...") if cleaned_json
          end
        '
      }
    }
  }
  
  # 处理有效的数据消息
  if [parsed_data][header] {
    
    # 提取基本信息
    mutate {
      add_field => {
        "msg_id" => "%{[parsed_data][header][msgId]}"
        "msg_type" => "%{[parsed_data][header][msgType]}"
        "sub_type" => "%{[parsed_data][header][subType]}"
        "gateway_sn" => "%{[parsed_data][device][gatewaySn]}"
        "data_type" => "%{[parsed_data][payload][dataType]}"
      }
    }
    
    # 提取设备序列号
    if [parsed_data][payload][sn] {
      mutate {
        add_field => { "device_sn" => "%{[parsed_data][payload][sn]}" }
      }
    }
    
    # 提取电池信息
    if [parsed_data][payload][bat] {
      mutate {
        add_field => { "battery_level" => "%{[parsed_data][payload][bat]}" }
        convert => { "battery_level" => "integer" }
      }
    }
    
    # 提取通道信息
    if [parsed_data][payload][channelNum] {
      mutate {
        add_field => { "channel_num" => "%{[parsed_data][payload][channelNum]}" }
        convert => { "channel_num" => "integer" }
      }
    }
    
    # 展开数据列表 (dataList) - 将数组转换为字符串以便存储
    if [parsed_data][payload][dataList] {
      ruby {
        code => '
          begin
            data_list = event.get("[parsed_data][payload][dataList]")
            if data_list && data_list.is_a?(Array)
              # 将数据列表转换为字符串
              event.set("data_list", data_list.to_json)
              event.set("data_count", data_list.length)
              
              # 提取第一个和最后一个数据点的时间戳
              if data_list.length > 0
                first_data = data_list.first
                last_data = data_list.last
                
                if first_data && first_data["time"]
                  event.set("first_data_time", first_data["time"])
                end
                
                if last_data && last_data["time"]
                  event.set("last_data_time", last_data["time"])
                end
              end
            end
          rescue => e
            event.set("data_list_error", e.message)
          end
        '
      }
    }
    
    # 展开单个数据字段
    if [parsed_data][payload][data] {
      mutate {
        add_field => { "sensor_data" => "%{[parsed_data][payload][data]}" }
      }
    }
    
    # 展开通道状态
    if [parsed_data][payload][channelState] {
      mutate {
        add_field => { "channel_state" => "%{[parsed_data][payload][channelState]}" }
      }
    }
  }
  
  # 添加服务标识
  mutate {
    add_field => { "service" => "iot_gateway" }
  }
  
  # 清理不需要的字段
  mutate {
    remove_field => [ "raw_json", "debug_original_json", "debug_cleaned_json" ]
  }
}

output {
  # 输出到 Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "iot-logs-%{+YYYY.MM.dd}"
  }
  
  # 输出到控制台用于调试
  stdout {
    codec => rubydebug
  }
}
