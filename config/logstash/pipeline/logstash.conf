input {
  beats {
    port => 5044
  }
}

filter {
  # 第一步：使用Ruby处理多行合并和前缀清理
  ruby {
    code => '
      begin
        message = event.get("message")
        if message
          # 使用正则表达式删除每行的前缀（时间戳和IP）
          cleaned_message = message.gsub(/^\[[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}\] \/[^:]+:\d+ -\s+/, "")
          
          # 设置清理后的消息
          event.set("cleaned_message", cleaned_message)
          
          # 检查是否是heartbeat消息
          if cleaned_message =~ /^\s*\{"heartbeat":/
            event.tag("heartbeat")
          end
        end
      rescue => e
        event.set("ruby_error", e.message)
      end
    '
  }
  
  # 第二步：过滤掉heartbeat消息
  if "heartbeat" in [tags] {
    drop {}
  }
  
  # 第三步：解析JSON
  json {
    source => "cleaned_message"
    target => "parsed_data"
    skip_on_invalid_json => true
  }
  
  # 第四步：如果JSON解析失败，记录错误
  if "_jsonparsefailure" in [tags] {
    mutate {
      add_field => { 
        "json_parse_error" => "true"
        "raw_json" => "%{cleaned_message}"
      }
    }
  }
  
  # 第五步：展平嵌套字段
  if [parsed_data] {
    # 从header提取msgId
    if [parsed_data][header][msgId] {
      mutate {
        add_field => { "msgId" => "%{[parsed_data][header][msgId]}" }
        convert => { "msgId" => "float" }
      }
    }
    
    # 提取msgType
    if [parsed_data][header][msgType] {
      mutate {
        add_field => { "msgType" => "%{[parsed_data][header][msgType]}" }
      }
    }
    
    # 提取subType
    if [parsed_data][header][subType] {
      mutate {
        add_field => { "subType" => "%{[parsed_data][header][subType]}" }
      }
    }
    
    # 提取gatewaySn
    if [parsed_data][device][gatewaySn] {
      mutate {
        add_field => { "gatewaySn" => "%{[parsed_data][device][gatewaySn]}" }
      }
    }
    
    # 提取dataType
    if [parsed_data][payload][dataType] {
      mutate {
        add_field => { "dataType" => "%{[parsed_data][payload][dataType]}" }
      }
    }
    
    # 提取sn
    if [parsed_data][payload][sn] {
      mutate {
        add_field => { "sn" => "%{[parsed_data][payload][sn]}" }
      }
    }
    
    # 提取bat
    if [parsed_data][payload][bat] {
      mutate {
        add_field => { "bat" => "%{[parsed_data][payload][bat]}" }
        convert => { "bat" => "integer" }
      }
    }
    
    # 处理dataList - 保持为原始数组格式
    if [parsed_data][payload][dataList] {
      ruby {
        code => '
          begin
            data_list = event.get("[parsed_data][payload][dataList]")
            if data_list && data_list.is_a?(Array)
              # 直接将dataList作为数组存储
              event.set("dataList", data_list)
            end
          rescue => e
            event.set("dataList_error", e.message)
          end
        '
      }
    }
    
    # 对于temperature类型的数据，处理data字段
    if [parsed_data][payload][dataType] == "temperature" {
      if [parsed_data][payload][data] {
        ruby {
          code => '
            begin
              data = event.get("[parsed_data][payload][data]")
              if data
                event.set("data", data)
              end
            rescue => e
              event.set("data_error", e.message)
            end
          '
        }
      }
      
      # 处理channelNum
      if [parsed_data][payload][channelNum] {
        mutate {
          add_field => { "channelNum" => "%{[parsed_data][payload][channelNum]}" }
          convert => { "channelNum" => "integer" }
        }
      }
      
      # 处理channelState
      if [parsed_data][payload][channelState] {
        ruby {
          code => '
            begin
              channel_state = event.get("[parsed_data][payload][channelState]")
              if channel_state
                event.set("channelState", channel_state)
              end
            rescue => e
              event.set("channelState_error", e.message)
            end
          '
        }
      }
      
      # 处理time
      if [parsed_data][payload][time] {
        mutate {
          add_field => { "time" => "%{[parsed_data][payload][time]}" }
          convert => { "time" => "integer" }
        }
      }
    }
  }
  
  # 设置@timestamp从msgId
  if [msgId] {
    ruby {
      code => '
        begin
          msg_id = event.get("msgId")
          if msg_id
            # msgId是以毫秒为单位的时间戳
            timestamp = Time.at(msg_id.to_f / 1000.0)
            event.set("@timestamp", timestamp)
          end
        rescue => e
          event.set("timestamp_error", e.message)
        end
      '
    }
  }
  
  # 清理不需要的字段
  mutate {
    remove_field => [ "message", "cleaned_message", "parsed_data", "host", "log", "input", "agent", "ecs", "event", "@version" ]
  }
  
  # 添加服务标识
  mutate {
    add_field => { "service" => "iot_gateway" }
  }
}

output {
  # 输出到 Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "iot-logs-%{+YYYY.MM.dd}"
    # 使用自定义的文档ID（可选）
    # document_id => "%{msgId}_%{gatewaySn}_%{sn}"
  }
  
  # 输出到控制台用于调试（生产环境可以注释掉）
  stdout {
    codec => rubydebug
  }
}
