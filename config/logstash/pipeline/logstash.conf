input {
  beats {
    port => 5044
  }
}

filter {
  # 过滤 heartbeat 消息
  if [message] =~ /.*"heartbeat".*/ {
    drop {}
  }

  # 解析日志行的基本结构: [timestamp] /ip:port - json_data
  grok {
    match => { 
      "message" => "^\[%{DATA:log_timestamp}\] /%{IPORHOST:client_ip}:%{INT:client_port} - %{GREEDYDATA:raw_json}" 
    }
    tag_on_failure => ["_grokparsefailure"]
  }
  
  # 解析时间戳
  if "_grokparsefailure" not in [tags] and [log_timestamp] {
    date {
      match => [ "log_timestamp", "yyyy-MM-dd HH:mm:ss" ]
      target => "log_time"
    }
  }
  
  # 清理并修复JSON数据
  if [raw_json] {
    # 清理JSON字符串 - 移除续行中的时间戳和IP信息
    mutate {
      gsub => [
        # 首先移除续行中的时间戳和IP前缀
        "raw_json", "\n\[[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}\] /[^:]+:\d+ - ", "",
        # 然后移除多余的换行符和空白字符
        "raw_json", "[\r\n\t]+", "",
        "raw_json", "\s+", " "
      ]
    }
    
    # 修复被断开的数字（如 "317 9" 应该是 "3179"）
    mutate {
      gsub => [
        "raw_json", "(\d+)\s+(\d+)", "\1\2"
      ]
    }
    
    # 尝试解析JSON
    json {
      source => "raw_json"
      target => "parsed_data"
      skip_on_invalid_json => true
    }
    
    # 如果JSON解析失败，尝试修复
    if "_jsonparsefailure" in [tags] {
      ruby {
        code => '
          begin
            raw_json = event.get("raw_json")
            if raw_json
              # 移除多余的空白字符
              cleaned_json = raw_json.strip
              
              # 尝试修复常见的JSON格式问题
              # 移除可能重复的时间戳行内容（针对多行日志）
              cleaned_json = cleaned_json.gsub(/\[[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}\] \/[^:]+:\d+ - /, "")
              
              # 修复被断开的数字（如 "317 9" 应该是 "3179"）
              cleaned_json = cleaned_json.gsub(/(\d+)\s+(\d+)/, "\\1\\2")
              
              # 移除多余的换行符和空白
              cleaned_json = cleaned_json.gsub(/[\r\n\t]+/, "")
              cleaned_json = cleaned_json.gsub(/\s+/, " ")
              
              # 记录修复前的JSON用于调试
              event.set("debug_original_json", raw_json)
              event.set("debug_cleaned_json", cleaned_json)
              
              # 尝试解析修复后的JSON
              parsed = JSON.parse(cleaned_json)
              event.set("parsed_data", parsed)
              event.remove("_jsonparsefailure")
              event.tag("_json_fixed")
            end
          rescue => e
            event.tag("_jsonparsefailure_final")
            event.set("json_error", e.message)
          end
        '
      }
    }
  }
  
  # 处理有效的数据消息
  if [parsed_data][header] {
    
    # 提取基本信息
    mutate {
      add_field => {
        "msg_id" => "%{[parsed_data][header][msgId]}"
        "msg_type" => "%{[parsed_data][header][msgType]}"
        "sub_type" => "%{[parsed_data][header][subType]}"
        "gateway_sn" => "%{[parsed_data][device][gatewaySn]}"
        "data_type" => "%{[parsed_data][payload][dataType]}"
      }
    }
    
    # 提取设备序列号
    if [parsed_data][payload][sn] {
      mutate {
        add_field => { "device_sn" => "%{[parsed_data][payload][sn]}" }
      }
    }
    
    # 提取电池信息
    if [parsed_data][payload][bat] {
      mutate {
        add_field => { "battery_level" => "%{[parsed_data][payload][bat]}" }
        convert => { "battery_level" => "integer" }
      }
    }
    
    # 提取通道信息
    if [parsed_data][payload][channelNum] {
      mutate {
        add_field => { "channel_num" => "%{[parsed_data][payload][channelNum]}" }
        convert => { "channel_num" => "integer" }
      }
    }
    
    # 展开数据列表 (dataList) - 将数组转换为字符串以便存储
    if [parsed_data][payload][dataList] {
      ruby {
        code => '
          begin
            data_list = event.get("[parsed_data][payload][dataList]")
            if data_list && data_list.is_a?(Array)
              # 将数据列表转换为字符串
              event.set("data_list", data_list.to_json)
              event.set("data_count", data_list.length)
              
              # 提取第一个和最后一个数据点的时间戳
              if data_list.length > 0
                first_data = data_list.first
                last_data = data_list.last
                
                if first_data && first_data["time"]
                  event.set("first_data_time", first_data["time"])
                end
                
                if last_data && last_data["time"]
                  event.set("last_data_time", last_data["time"])
                end
              end
            end
          rescue => e
            event.set("data_list_error", e.message)
          end
        '
      }
    }
    
    # 展开单个数据字段
    if [parsed_data][payload][data] {
      mutate {
        add_field => { "sensor_data" => "%{[parsed_data][payload][data]}" }
      }
    }
    
    # 展开通道状态
    if [parsed_data][payload][channelState] {
      mutate {
        add_field => { "channel_state" => "%{[parsed_data][payload][channelState]}" }
      }
    }
  }
  
  # 添加服务标识
  mutate {
    add_field => { "service" => "iot_gateway" }
  }
  
  # 清理不需要的字段
  mutate {
    remove_field => [ "raw_json", "debug_original_json", "debug_cleaned_json" ]
  }
}

output {
  # 输出到 Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "iot-logs-%{+YYYY.MM.dd}"
  }
  
  # 输出到控制台用于调试
  stdout {
    codec => rubydebug
  }
}
